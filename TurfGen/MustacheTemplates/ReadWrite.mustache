// Autogenerated by TurfGen {{version}}
// ANY CHANGES WILL BE AUTOMATICALLY OVERWRITTEN
import Turf

{{accessibility}}protocol {{collectionsContainerProtocolName}} { }
extension {{containerTypeName}}: {{collectionsContainerProtocolName}} { }

{{accessibility}}class {{readOnlyContainerTypeName}} {
{{# collections }}
    {{accessibility}}lazy var {{name}}: ReadCollection<{{typeName}}, {{containerTypeName}}> = {
        [unowned self] in
        return self.transaction.readOnly(self.transaction.collections.{{name}})
    }()
{{/ collections }}

    {{accessibility}}let transaction: ReadTransaction<{{containerTypeName}}>

    // MARK: Object lifecycle

    private init(transaction: ReadTransaction<{{containerTypeName}}>) {
        self.transaction = transaction
    }
}


{{accessibility}}class {{readWriteContainerTypeName}} {
{{# collections }}
    {{accessibility}}lazy var {{name}}: ReadWriteCollection<{{typeName}}, {{containerTypeName}}> = {
        [unowned self] in
        return self.transaction.readWrite(self.transaction.collections.{{name}})
    }()
{{/ collections }}

    {{accessibility}}let transaction: ReadWriteTransaction<{{containerTypeName}}>

    // MARK: Object lifecycle

    private init(transaction: ReadWriteTransaction<{{containerTypeName}}>) {
        self.transaction = transaction
    }
}

{{accessibility}}class Safe{{readWriteContainerTypeName}}: {{readOnlyContainerTypeName}} {

    {{accessibility}}lazy var readWrite: {{readWriteContainerTypeName}} = {
        [unowned self] in
            return {{readWriteContainerTypeName}}(transaction: self.readWriteTransaction)
        }()

    // MARK: Object lifecycle

    private let readWriteTransaction: ReadWriteTransaction<{{containerTypeName}}>

    private init(transaction: ReadWriteTransaction<{{containerTypeName}}>) {
        self.readWriteTransaction = transaction
        super.init(transaction: transaction)
    }
}


extension Connection where Collections: {{collectionsContainerProtocolName}} {
    {{accessibility}}func readOnly(closure: {{readOnlyContainerTypeName}} -> Void) throws {
        try readTransaction { transaction, collections in
            let readOnlyCollections = {{readOnlyContainerTypeName}}(transaction: (transaction as? ReadTransaction<{{containerTypeName}}>)!)
            closure(readOnlyCollections)
        }
    }

    {{accessibility}}func readWrite(closure: Safe{{readWriteContainerTypeName}} throws -> Void) throws {
        try readWriteTransaction { transaction, collections in
            let readWriteCollections = Safe{{readWriteContainerTypeName}}(transaction: (transaction as! ReadWriteTransaction<{{containerTypeName}}>))
            try closure(readWriteCollections)
        }
    }
}

